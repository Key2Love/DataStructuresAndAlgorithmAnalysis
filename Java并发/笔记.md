

# Java多线程与高并发

###### **事务的四个特性(CAID)：**

**原子性**：要么全部成功commit,要么全部失败rollback.

**一致性**：rollback后的数据和原来的一致。

**隔离性**：事务和事务之间不干扰。一个事务必须与另外一个事务的执行结果隔离开。

**持久性**：执行成功。持久化数据。



## 进程与线程

- 进程是cpu资源调度的最小单位
- 线程是程序执行的最小单位，一个进程可产生多个线程

## 启动线程的三种方式

- ```java
  new Thread().start
  new Thread(runnable).start
  Executors.newCachedThreadPool()
  ```

- 线程的三种方法

  - sleep 到了时间自动复活
  - yield 让出cpu，回到等待队列。
  - join  t1,t2两个线程，在t1的某个点上调用t2.join。它会跑到t2去运行。t1等待t2运行完毕继续t1运行。

- 线程的五大状态

  ![img](https://pic2.zhimg.com/80/v2-326a2be9b86b1446d75b6f52f54c98fb_1440w.jpg)

  

  new ready running waiting  blocked timewaiting erminated

  java中，**线程的状态使用一个枚举类型来描述的**。这个枚举一共有6个值: **NEW(新建)、RUNNABLE(运行)、BLOCKED(锁池)、TIMED_WAITING(定时等待)、WAITING(等待)、TERMINATED(终止、结束)。**

  ## synchronized关键字

  - 多个资源去访问同一个资源的时候对这个资源上锁
  
  - ```java
    //锁住当前对象
    public void m(){
        synchronized(this)
    }
    //等同于
    public synchronized void m(){
        
    }
    //静态方法static是没有this对象的，如果在方法上加一个synchronized的话就代表synchronized(T.class)。
    public synchronized static void m(){ //这里等同synchronized(T.class)
        
    }
    ```
  
  - 同步方法与非同步方法可以同时调用
  
    - 会产生脏读问题
  
      ```java
      //比如对余额写方法加锁，读方法不加锁。则有可能写入还未完成读到了中间值
      public void read(){}
      public synchronized void write(){}
      ```
  
      
  
  - 可重入
    - 一个同步方法调用另一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁。
    - 通俗来说：当线程请求一个由其它线程持有的对象锁时，该线程会阻塞，而当线程请求由自己持有的对象锁时，如果该锁是重入锁，请求就会成功，否则阻塞。
  - 异常锁
    
    - 程序在执行过程中，如果出现异常，默认情况锁会被释放。
  - synchronized不能用String常量，Integer，Long
  - 锁升级
    
    - 偏向锁-自旋锁-重量锁
  
  ## 第二节：volatile与CAS（compareAndSet）
  
  ## volatile
  
  - volatile使一个变量在多个线程间可见。volatile不能替代syncronized
  
  - 线程可见
  
    - 堆内存是所有线程共享里面的内存，除了堆内存之外，每个线程都有自己的工作内存。
  
      对一个变量添加volatile关键字能保证一个线程的改变，另一个线程就能看到。
  
  - 禁止指令重排序 
  
    - DCL单例 （Double Check Lock）
  
      单例保证在JVM内存里只有某个类的一个实例，比如权限管理者类
  
      最简单写法
  
      ```java
      class DCLmode {
          private static final DCLmode INSTANCE = new DCLmode();
          private DCLmode(){
      
          }
          public static DCLmode getInstance(){
              return INSTANCE;
          }
      
          public static void main(String[] args) {
              DCLmode a = DCLmode.getInstance();
          }
      
      }
      ```
  
      
  
      ```java
  class DCLmode1 {
          private static volatile DCLmode1 INSTANCE;
      
          private DCLmode1() {}
  
          public static DCLmode1 getInstance() {
              if (INSTANCE == null) { //第一次检查
                  synchronized (DCLmode1.class) { //加锁
                      if (INSTANCE == null) { //第二次检查
                          INSTANCE = new DCLmode1();
                      }
                  }
              }
              return INSTANCE;
          }
      }
      ```
      
      第7行的代码创建了一个对象，这一行代码可以分解成3个操作：

```java
memory = allocate();　　// 1：分配对象的内存空间
ctorInstance(memory);　// 2：初始化对象
instance = memory;　　// 3：设置instance指向刚分配的内存地址
```

​					根源在于代码中的2和3之间，可能会被重排序。例如：

```java
memory = allocate();　　// 1：分配对象的内存空间
instance = memory;　　// 3：设置instance指向刚分配的内存地址
// 注意，此时对象还没有被初始化！
ctorInstance(memory);　// 2：初始化对象
```

- 总结
  - synchronized锁的是对象不是代码，锁方法锁的是this，锁static方法锁的是class，锁定方法和非锁定方法是可以同时执行的，锁升级从偏向锁到自旋锁到重量级锁。
  - vvolatile保证线程可见性，保证了禁止指令重排序。线程可见性是通过cpu缓存一致性实现，禁止指令重排序是虚拟机级别。

## CAS

- CAS 无锁优化，自旋锁，乐观锁

  ```java
  cas(V,Expected,NewValue){
  	while(V==E){
  		V = NewValue;
  	}	
  }
  ```

- ABA

  - 一个变量经过A->B->A的变化之后，还是能通过CAS。解决方法是加一个stamp版本号。

## 第三节：Atomic类和线程同步的新机制

- 很多线程对于一个数进行递增

  - long型，递增的时候加锁
  - AtomicLong使它不断向上递增
  - Longadder
  - 速度：sync<AtomicLong<longadder。sync要加锁，很可能变成重量锁。Longadder内部做了一个分段锁。

- Longadder

  - 首先和AtomicLong一样，都会先采用**cas**方式更新值在初次cas方式失败的情况下(通常证明多个线程同时想更新这个值)，尝试将这个值**分隔成多个cell**（sum的时候求和就好），让这些竞争的线程只管更新自己所属的cell（因为在rehash之前，每个线程中存储的hashcode不会变，所以每次都应该会找到同一个cell），这样就将竞争压力分散了。
  - ReentranLock
    - TODO [关于这块的源码解读](https://zhuanlan.zhihu.com/p/37427030)
      - 可以代替synchronized，本身的底层是CAS
      - 默认是非公平，可以公平于非公平切换。
      - trylock：线程不会阻塞。能拿到就拿到，拿不到也无所谓。
        - 自己来控制。本质是是进行一次CAS，即使该lock是公平锁也要变成非公平锁。如果不能获得，return false。

- synchronized和reentranlock的区别

  - 这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成

    便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。

    锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized

- ReadWriteLock

  - 共享锁+排他锁。 